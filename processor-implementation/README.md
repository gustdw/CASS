# Homework assignment: Extending the single-cycle implementation with an additional instruction

The objective of this homework is to better understand the single-cycle
implementation of a RISC-V processor that we studied in class by extending it
with support for one additional instruction.

## Preparation

Make sure that you have read Sections 4.1 - 4.4 of the textbook, and that you
have attended (or watched the recording of) the corresponding lecture(s).

The processor implementation we studied in class is available in the file
`SingleCycleCPU.sv`. That processor implementation supports the instructions:
`lw`, `sw`, `add`, `sub`, `and`, `or` and `beq`.

In this homework, you will extend this implementation to additionally support
the `addi` instruction.

## Exercise 1: Use a simulator to run a program on the provided processor implementation

Study the `testbench-CPU.sv` code that will drive the CPU implementation. The
code is heavily documented to make it easy to understand what is going on.

You can run a simulation by typing `make cpu` at the command line. If you do
that without changing any of the provided files, you should see:

```
iverilog -g2005-sv -o sim SingleCycleCPU.sv testbench-CPU.sv
./sim
VCD info: dumpfile cpu.vcd opened for output.
PC =  00000000
```

The first line shows how `iverilog` is used to compile `SingleCycleCPU.sv` and
`testbench-CPU.sv` into a `sim` executable. Then `sim` is executed to run the
simulation.

The last two lines are output of the simulation. Make sure you understand what
happens: the testbench loads instruction memory of the CPU with
`empty.machinecode` which contains the instruction `add x0,x0,x0` (encoded as
`0x00000033`). Hence, the CPU asserts done as soon as it executes the first
instruction. One of the debug statements in `testbench-CPU.sv` prints
`PC=00000000` and then the simulation finishes.

Now, solve the following exercises:

- change the machine code in `empty.machinecode` so that it starts with a
  `sw x0,0(x0)` instruction, and run the simulation again. What is the output
  now?
- change the machine code so that it executes:
  ```
  lw x1,0(x0)
  sw x1,4(x0)
  ```
  What is the output now?
- Optional, but recommended: Use a wave viewer program to look at the signals in
  the `cpu.vcd` file generated by the last simulation.

  Visualize the `clk`, `done`, `CPU.outPC` , `CPU.instruction`, `CPU.MemWrite`,
  `CPU.DataMemory.a` and `CPU.DataMemory.wd` signals. Check that all the signals
  indeed evolve as you would expect.

## Exercise 2: Make the CPU run a real program

The program `fib1.s` is a RISC-V assembly language program that only uses the 7
instructions supported by our processor implementation. Read the code and make
sure you understand what it does. You will notice that programming with only
these 7 instructions is a bit awkward. For instance, getting a specific constant
in a register requires multiple instructions, and the assumption that some base
constant is present in data memory.

The file `fib1.machinecode` contains the corresponding machinecode. Change the
`testbench-CPU.sv` program to load this machinecode, and run the simulation
again.

Check that the hardware signals evolve as you would expect, either by adding
`$display` statements to the test bench, or by visualizing the signals with
a wave viewer program.

For instance, check how the `CPU.outPC` value evolves. Does it go through the
loop of `fib1.s` as you would expect? (It should!)

## Exercise 3: Try out a program with unsupported instructions

Now look at the program `fib2.s`. This program avoids some of the awkwardness of
`fib1.s` by using the instruction `addi` to load constants in registers.
However, this program fails on our processor implementation.

The file `fib2.machinecode` contains the corresponding machinecode. Change the
`testbench-CPU.sv` program to load this machinecode, and run the simulation
again.

This program will of course **not** behave correctly, since it uses instructions
not supported by the CPU implementation.

Look at the signals of the failing execution, or add `$display` statements to
understand what happens.

- Can you determine where things go wrong? What is the effect of the `addi`
  instruction?

## Exercise 4: Implement support for the `addi` instruction

Once you understand how the `addi` instruction fails, implement a fix in
`SingleCycleCPU.sv`, such that implements the instruction correctly.

Once the program `fib2.s` works correctly on your fixed processor, you can be
reasonably sure that you have implemented support for `addi` correctly.

Debugging your implementation can be done by adding debug statements in
`testbench-CPU.sv`, and/or by looking at the signals of an incorrect simulation
in a waveform viewer.
